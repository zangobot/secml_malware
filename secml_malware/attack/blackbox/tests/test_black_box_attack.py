from pathlib import Path

import lief.PE

from secml_malware.attack.blackbox.c_black_box_format_exploit_evasion import CBlackBoxFormatExploitEvasionProblem
from secml_malware.attack.blackbox.c_black_box_padding_evasion import CBlackBoxPaddingEvasionProblem
from secml_malware.attack.blackbox.c_blackbox_header_problem import CBlackBoxHeaderEvasionProblem
from secml_malware.attack.blackbox.c_blackbox_headerfields_problem import CBlackBoxHeaderFieldsEvasionProblem
from secml_malware.attack.blackbox.c_gamma_evasion import CGammaEvasionProblem
from secml_malware.attack.blackbox.c_gamma_sections_evasion import CGammaSectionsEvasionProblem
from secml_malware.attack.blackbox.c_wrapper_phi import CEmberWrapperPhi, CEnd2EndWrapperPhi
from secml_malware.attack.blackbox.ga.c_base_genetic_engine import CGeneticAlgorithm
from secml_malware.attack.blackbox.tests.black_box_base_test import BlackBoxBaseTests


class BlackBoxEvasionAttackTestSuite(BlackBoxBaseTests):

    def test_blackbox_format_exploit_ember(self):
        black_box_attack = CBlackBoxFormatExploitEvasionProblem(
            CEmberWrapperPhi(self.ember_classifier),
            preferable_extension_amount=0x200,
            pe_header_extension=0,
            iterations=5,
            population_size=10
        )
        engine = CGeneticAlgorithm(black_box_attack)
        y_pred, _, _, _ = engine.run(self.X, self.Y)
        self.assert_evasion_result(y_pred)

    def test_blackbox_format_exploit_malconv(self):
        black_box_attack = CBlackBoxFormatExploitEvasionProblem(
            CEnd2EndWrapperPhi(self.end2end_classifier),
            preferable_extension_amount=0x200,
            pe_header_extension=0,
            iterations=5,
            population_size=10
        )
        engine = CGeneticAlgorithm(black_box_attack)
        y_pred, _, _, _ = engine.run(self.X, self.Y)
        self.assert_evasion_result(y_pred)

    def test_blackbox_partial_dos_header_malconv(self):
        black_box_attack = CBlackBoxHeaderEvasionProblem(
            CEnd2EndWrapperPhi(self.end2end_classifier),
            optimize_all_dos=False,
            iterations=5,
            population_size=10
        )
        engine = CGeneticAlgorithm(black_box_attack)
        y_pred, _, _, _ = engine.run(self.X, self.Y)
        self.assert_evasion_result(y_pred)

    def test_blackbox_padding_malconv(self):
        black_box_attack = CBlackBoxPaddingEvasionProblem(
            CEnd2EndWrapperPhi(self.end2end_classifier),
            how_many_padding_bytes=1024,
            iterations=5,
            population_size=10
        )
        engine = CGeneticAlgorithm(black_box_attack)
        y_pred, _, _, _ = engine.run(self.X, self.Y)
        self.assert_evasion_result(y_pred)

    def test_blackbox_dos_header_malconv(self):
        black_box_attack = CBlackBoxHeaderEvasionProblem(
            CEnd2EndWrapperPhi(self.end2end_classifier),
            optimize_all_dos=True,
            iterations=2,
            population_size=2
        )
        engine = CGeneticAlgorithm(black_box_attack)
        y_pred, _, _, _ = engine.run(self.X, self.Y)
        self.assert_evasion_result(y_pred)

    def test_blackbox_header_fields_malconv(self):
        black_box_attack = CBlackBoxHeaderFieldsEvasionProblem(
            CEnd2EndWrapperPhi(self.end2end_classifier),
            iterations=2,
            population_size=2
        )
        engine = CGeneticAlgorithm(black_box_attack)
        y_pred, _, _, _ = engine.run(self.X, self.Y)
        self.assert_evasion_result(y_pred)

    def test_blackbox_gamma_malconv(self):
        section_population, _ = CGammaEvasionProblem.create_section_population_from_folder(self.goodware_folder, 10)
        gamma = CGammaEvasionProblem(section_population, CEnd2EndWrapperPhi(self.end2end_classifier),
                                     population_size=10, penalty_regularizer=1e-6, iterations=5)
        engine = CGeneticAlgorithm(gamma)
        y_pred, _, _, _ = engine.run(self.X, self.Y)
        self.assert_evasion_result(y_pred)

    def test_blackbox_gamma_ember(self):
        section_population, _ = CGammaEvasionProblem.create_section_population_from_folder(self.goodware_folder, 100)
        gamma = CGammaEvasionProblem(section_population, CEmberWrapperPhi(self.ember_classifier),
                                     population_size=10, penalty_regularizer=1e-6, iterations=5)
        engine = CGeneticAlgorithm(gamma)
        y_pred, _, _, _ = engine.run(self.X, self.Y)
        self.assert_evasion_result(y_pred)

    def test_blackbox_gamma_gbdt_ember(self):
        section_population, _ = CGammaSectionsEvasionProblem.create_section_population_from_folder(self.goodware_folder,
                                                                                                   75)
        gamma = CGammaSectionsEvasionProblem(section_population, CEmberWrapperPhi(self.ember_classifier),
                                             population_size=10, penalty_regularizer=1e-6, iterations=2)
        engine = CGeneticAlgorithm(gamma, is_debug=True)
        y_pred, _, adv_ds, _ = engine.run(self.X, self.Y)
        x_adv = adv_ds[0, :].X
        path = str(Path(__file__).parent / "adv_test.file")
        engine.write_adv_to_file(x_adv, path)
        loaded_adv_pe = lief.PE.parse(path)
        adv_pe = lief.PE.parse(x_adv.tolist()[0])
        loaded_sections = [s.name for s in loaded_adv_pe.sections]
        adv_sections = [s.name for s in adv_pe.sections]
        self.assert_evasion_result(y_pred)
        self.assert_array_equal(loaded_sections, adv_sections)

    def test_blackbox_sections_gamma_ember(self):
        section_population, _ = CGammaSectionsEvasionProblem.create_section_population_from_folder(self.goodware_folder,
                                                                                                   100)
        gamma = CGammaSectionsEvasionProblem(section_population, CEmberWrapperPhi(self.ember_classifier),
                                             population_size=3, penalty_regularizer=1e-6, iterations=4)
        engine = CGeneticAlgorithm(gamma)
        y_pred, _, _, _ = engine.run(self.X, self.Y)
        self.assert_evasion_result(y_pred)

    def test_gbdt_wrapper_batch_prediction(self):
        wrapper = CEmberWrapperPhi(self.ember_classifier)
        self._batch_prediction_of_wrapper(wrapper)

    def test_e2e_wrapper_batch_prediction(self):
        wrapper = CEnd2EndWrapperPhi(self.end2end_classifier)
        self._batch_prediction_of_wrapper(wrapper)


