import hashlib
import json
from abc import ABC
from enum import Enum
from time import sleep
from urllib.parse import urlparse

import numpy as np
import requests
from secml.array import CArray
from secml.ml.classifiers import CClassifier


def is_valid_url(url):
    result = urlparse(url)
    return result.scheme and result.netloc


class AvailableOnlineAntivirus(Enum):
    VirusTotal = 'VirusTotal'
    # MetaDefender = 'MetaDefender' -- will be included in the future
    Local = 'Local'


class OnlineAntivirus(ABC):

    def analyse_sample(self, sample: bytes):
        ...


class LocalOnlineAntivirus(OnlineAntivirus):
    def __init__(self, api_url: str):
        self.url = api_url

    def analyse_sample(self, sample: bytes):
        files = {"file": (hashlib.sha256(sample).hexdigest(), sample, "application/octet-stream")}
        headers = {"accept": "application/json"}
        response = requests.post(self.url, files=files, headers=headers)
        return float(response.text)


class VirusTotalOnlineAntivirus(OnlineAntivirus):
    def __init__(self, api_key: str, delay: float = 20):
        self.api_key = api_key
        self.delay = delay

    def analyse_sample(self, sample: bytes):
        url = "https://www.virustotal.com/api/v3/files"
        file_hash = hashlib.sha256(sample).hexdigest()
        files = {"file": (file_hash, sample, "application/octet-stream")}
        headers = {"accept": "application/json", "x-apikey": self.api_key}
        post_response = requests.post(url, files=files, headers=headers)
        if post_response.status_code != 200:
            raise Exception("VirusTotal did nto accept the input. Error was:", post_response.text)
        # Check post_response.status_code == 200
        sleep(self.delay)

        url = f"https://www.virustotal.com/api/v3/files/{file_hash}"
        headers = {"accept": "application/json", "x-apikey": self.api_key}
        get_response = requests.get(url, headers=headers)
        if get_response.status_code != 200:
            raise Exception("VirusTotal did nto accept the input. Error was:", get_response.text)
        data = json.loads(get_response.content)["data"]["attributes"]
        if "last_analysis_results" not in data:
            raise Exception("VirusTotal has not concluded the analysis.")
        av_responses = data["last_analysis_results"]
        how_many_detections = sum([av_responses[a]["category"] == "malicious" for a in av_responses.keys()])
        return how_many_detections / len(av_responses)


class CClassifierRemote(CClassifier):

    def __init__(self, antivirus: AvailableOnlineAntivirus = AvailableOnlineAntivirus.Local,
                 url: str = None,
                 api_key: str = None,
                 threshold: float = 0.5):
        """
        Creates the Remote Classifier.

        Parameters
        ----------
        url : str
                remote server URL
        """
        super(CClassifierRemote, self).__init__()
        self._url = url
        self._antivirus_key = antivirus
        self._apiKey = api_key
        if antivirus == AvailableOnlineAntivirus.Local:
            if not is_valid_url(url):
                raise ValueError("Please, provide a valid URL to reach your local server")
        self._antivirus = self._initialize_remote_antivirus()
        self._classes = np.array([0, 1])
        self._n_features = 2
        self._threshold = threshold

    def get_url(self):
        return self._url

    def _backward(self, w):
        raise NotImplementedError("Backward is not implemented.")

    def _fit(self, x, y):
        raise NotImplementedError("Fit is not implemented.")

    def _initialize_remote_antivirus(self):
        if self._antivirus_key == AvailableOnlineAntivirus.VirusTotal:
            return VirusTotalOnlineAntivirus(self._apiKey)

        return LocalOnlineAntivirus(self._url)

    def _forward(self, x):
        x_list = x.tolist()[0]
        x_bytes = b''.join([bytes([int(i)]) for i in x_list])
        confidence = self._antivirus.analyse_sample(x_bytes)
        score = CArray.zeros((1, 2))
        score[0, 1] = confidence
        score[0, 0] = 1 - confidence
        return score

    def predict(self, x, return_decision_function=False):
        scores = self.decision_function(x, y=None)
        # The classification label is the label of the class
        # associated with the highest score
        labels = (scores[:, 1] > self._threshold).astype(int)

        return (labels, scores) if return_decision_function is True else labels
