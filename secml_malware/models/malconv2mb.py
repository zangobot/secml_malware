import io
import os
import sys
from pathlib import Path

import requests
import torch
import torch.nn.functional as F
from secml.settings import SECML_PYTORCH_USE_CUDA

from secml_malware.models import End2EndModel

use_cuda = torch.cuda.is_available() and SECML_PYTORCH_USE_CUDA


class MalConv2MB(End2EndModel):

    def __init__(self, out_size=2, channels=256, window_size=512, embd_size=8):
        super(MalConv2MB, self).__init__(embedding_size=8, max_input_size=2000000, embedding_value=0, shift_values=True)
        self.embd = torch.nn.Embedding(257, embd_size, padding_idx=0)

        self.window_size = window_size

        self.conv_1 = torch.nn.Conv1d(embd_size, channels, window_size, stride=window_size, bias=True)
        self.conv_2 = torch.nn.Conv1d(embd_size, channels, window_size, stride=window_size, bias=True)

        self.pooling = torch.nn.AdaptiveMaxPool1d(1)

        self.fc_1 = torch.nn.Linear(channels, channels)
        self.fc_2 = torch.nn.Linear(channels, out_size)

    def embed(self, input_x, transpose=True):
        if isinstance(input_x, torch.Tensor):
            x = input_x.clone().detach().requires_grad_(True).type(torch.LongTensor)
        else:
            x = torch.from_numpy(input_x).type(torch.LongTensor)
        x = x.squeeze(dim=1)
        if use_cuda:
            x = x.cuda()
        emb_x = self.embd(x)
        if transpose:
            emb_x = torch.transpose(emb_x, 1, 2)
        return emb_x

    def embedd_and_forward(self, x):
        cnn_value = self.conv_1(x)
        gating_weight = torch.sigmoid(self.conv_2(x))

        x = cnn_value * gating_weight

        x = self.pooling(x)

        # flatten
        x = x.view(x.size(0), -1)

        x = F.relu(self.fc_1(x))
        x = self.fc_2(x)
        x = torch.nn.functional.softmax(x, dim=1)
        return x

    def load_simplified_model(self, url: str = None):
        if url is None:
            url = "https://github.com/dtrizna/quo.vadis/raw/main/modules/sota/malconv/parameters/malconv.checkpoint"
        root = os.path.dirname(
            os.path.dirname(os.path.abspath(sys.modules["secml_malware"].__file__))
        )
        save_path = Path(root) / "secml_malware" / "data" / "trained" / "malconv2mb_checkpoint.pth"

        if not save_path.exists():
            malconv_weights = requests.get(url).content
            with open(save_path, "wb") as f:
                f.write(malconv_weights)
        else:
            with open(save_path, "rb") as f:
                malconv_weights = f.read()
        malconv_weights = torch.load(io.BytesIO(malconv_weights), map_location='cpu')
        self.load_state_dict(malconv_weights["model_state_dict"])
